# é’©å­ç¤ºä¾‹

å¯å¤åˆ¶å¹¶è°ƒæ•´çš„ç°å®ä¸–ç•Œé’©å­æ¨¡å¼ã€‚

## å®‰å…¨ï¼šé˜»æ­¢å±é™©å‘½ä»¤

```typescript
export async function PreToolUse(input: PreToolUseHookInput) {
  if (input.tool_name === 'Bash') {
    const cmd = input.tool_input?.command as string;
    const blacklist = [
      /rm\s+-rf\s+\//,
      /dd\s+if=/,
      /mkfs/,
      /:\(\)\{ :\|:\& \};:/  // fork bomb
    ];

    for (const pattern of blacklist) {
      if (pattern.test(cmd)) {
        return {
          decision: 'deny',
          message: `Blocked dangerous command: ${cmd}`
        };
      }
    }
  }

  return { decision: 'approve' };
}
```

## å®¡è®¡ï¼šè®°å½•æ‰€æœ‰æ“ä½œ

```typescript
import { appendFileSync } from 'fs';
import { join } from 'path';

export async function PostToolUse(input: PostToolUseHookInput) {
  const logPath = join(process.cwd(), 'audit.log');

  const entry = {
    timestamp: new Date().toISOString(),
    tool: input.tool_name,
    input: input.tool_input,
    success: !input.tool_response?.error,
    error: input.tool_response?.error
  };

  appendFileSync(logPath, JSON.stringify(entry) + '\n');

  return {};
}
```

## ä»“åº“ï¼šåˆå§‹åŒ–é¡¹ç›®ç»“æ„

```typescript
import { mkdirSync, writeFileSync, appendFileSync } from 'fs';
import { join } from 'path';

export async function RepositoryInit(input: RepositoryInitHookInput) {
  const { workspace_path } = input;

  // .gitignore
  appendFileSync(join(workspace_path, '.gitignore'), `
.env
node_modules/
dist/
`);

  // README.md
  writeFileSync(join(workspace_path, 'README.md'), `# Project

Created by Agentrix
`);

  // src/ directory
  mkdirSync(join(workspace_path, 'src'), { recursive: true });

  return {};
}
```

## é›†æˆï¼šé€šçŸ¥å¤–éƒ¨ç³»ç»Ÿ

```typescript
export async function SessionStart(input: SessionStartHookInput) {
  try {
    await fetch('https://hooks.slack.com/services/YOUR/WEBHOOK/URL', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        text: `ğŸ¤– Agent session started: ${input.session_id}`
      })
    });
  } catch (error) {
    console.error('Failed to notify Slack:', error);
  }

  return {};
}
```

## æŒ‡æ ‡ï¼šè¿½è¸ªå·¥å…·ä½¿ç”¨

```typescript
const toolCounts = new Map<string, number>();

export async function PreToolUse(input: PreToolUseHookInput) {
  const count = toolCounts.get(input.tool_name) || 0;
  toolCounts.set(input.tool_name, count + 1);

  console.log('[Metrics] Tool usage:', Object.fromEntries(toolCounts));

  return { decision: 'approve' };
}

export async function SessionEnd(input: SessionEndHookInput) {
  console.log('[Final Metrics]', Object.fromEntries(toolCounts));
  toolCounts.clear();

  return {};
}
```

## éªŒè¯ï¼šå¼ºåˆ¶æ–‡ä»¶å‘½å

```typescript
export async function PreToolUse(input: PreToolUseHookInput) {
  if (input.tool_name === 'Write' || input.tool_name === 'Edit') {
    const filePath = input.tool_input?.file_path as string;

    // Enforce kebab-case for file names
    const fileName = filePath.split('/').pop();
    if (fileName && !/^[a-z0-9-]+\.[a-z]+$/.test(fileName)) {
      return {
        decision: 'deny',
        message: `File name must be kebab-case: ${fileName}`
      };
    }
  }

  return { decision: 'approve' };
}
```

## ä½¿ç”¨ AgentrixContextï¼šä»»åŠ¡æ„ŸçŸ¥å®¡è®¡æ—¥å¿—

ä½¿ç”¨å·¥å‚æ¨¡å¼è®¿é—®ä»»åŠ¡å’Œå·¥ä½œåŒºä¿¡æ¯ï¼š

```typescript
import { appendFileSync } from 'fs';
import { join } from 'path';
import type { HookFactory, AgentrixContext } from '@agentrix/shared';
import type { PostToolUseHookInput } from '@anthropic-ai/claude-agent-sdk';

const createHooks: HookFactory = (context: AgentrixContext) => ({
  PostToolUse: async (
    input: PostToolUseHookInput,
    toolUseID: string,
    options: { signal: AbortSignal }
  ) => {
    const workspace = context.getWorkspace();
    const taskId = context.getTaskId();
    const userId = context.getUserId();

    // Write audit log to workspace
    const logPath = join(workspace, '.agentrix', 'audit.log');

    const entry = {
      timestamp: new Date().toISOString(),
      taskId,
      userId,
      tool: input.tool_name,
      input: input.tool_input,
      success: !input.tool_response?.error,
    };

    appendFileSync(logPath, JSON.stringify(entry) + '\n');

    return {};
  },
});

export default createHooks;
```

## ä½¿ç”¨ AgentrixContextï¼šä»»åŠ¡èŒƒå›´æŒ‡æ ‡

ä½¿ç”¨é—­åŒ…å˜é‡æŒ‰ä»»åŠ¡è·Ÿè¸ªæŒ‡æ ‡ï¼š

```typescript
import type { HookFactory, AgentrixContext } from '@agentrix/shared';
import type {
  PreToolUseHookInput,
  SessionEndHookInput
} from '@anthropic-ai/claude-agent-sdk';

const createHooks: HookFactory = (context: AgentrixContext) => {
  // Closure variable - scoped to this task
  const toolCounts = new Map<string, number>();
  const startTime = Date.now();

  return {
    PreToolUse: async (input: PreToolUseHookInput) => {
      const count = toolCounts.get(input.tool_name) || 0;
      toolCounts.set(input.tool_name, count + 1);

      console.log(`[Task ${context.getTaskId()}] Tool: ${input.tool_name} (${count + 1}x)`);

      return { decision: 'approve' as const };
    },

    SessionEnd: async (input: SessionEndHookInput) => {
      const duration = Date.now() - startTime;

      console.log(`[Task ${context.getTaskId()}] Session Summary:`);
      console.log(`  Duration: ${Math.round(duration / 1000)}s`);
      console.log(`  User: ${context.getUserId()}`);
      console.log(`  Tools used:`, Object.fromEntries(toolCounts));

      return {};
    },
  };
};

export default createHooks;
```

## ä½¿ç”¨ AgentrixContextï¼šå·¥ä½œåŒºæ„ŸçŸ¥å®‰å…¨

éªŒè¯æ–‡ä»¶æ“ä½œæ˜¯å¦åœ¨å·¥ä½œåŒºè¾¹ç•Œå†…ï¼š

```typescript
import { resolve } from 'path';
import type { HookFactory, AgentrixContext } from '@agentrix/shared';
import type { PreToolUseHookInput } from '@anthropic-ai/claude-agent-sdk';

const createHooks: HookFactory = (context: AgentrixContext) => ({
  PreToolUse: async (input: PreToolUseHookInput) => {
    const workspace = context.getWorkspace();

    // Check file operations stay within workspace
    if (input.tool_name === 'Write' || input.tool_name === 'Read' || input.tool_name === 'Edit') {
      const filePath = input.tool_input?.file_path as string;

      if (filePath) {
        const resolvedPath = resolve(workspace, filePath);

        // Prevent path traversal
        if (!resolvedPath.startsWith(workspace)) {
          return {
            decision: 'deny' as const,
            message: `Access denied: ${filePath} is outside workspace`,
          };
        }
      }
    }

    return { decision: 'approve' as const };
  },
});

export default createHooks;
```

## ç›¸å…³

*   [é’©å­æ¦‚è¿°](1.overview.md)
*   [å¼€å‘æŒ‡å—](3.development-guide.md)
*   [é’©å­ç±»å‹å‚è€ƒ](4.hook-types.md)
