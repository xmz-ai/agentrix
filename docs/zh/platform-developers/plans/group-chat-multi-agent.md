# Group Chat 多 Agent 协作模式方案（产品视角草案）

## 背景与用户期望

用户希望把"与 AI 协作"当成日常聊天：像用传统 IM 一样熟悉、自然、低门槛。
无论是私聊还是群聊，用户不关心任务、会话、worker 这些概念，只关心：
我说一句话，谁在听、谁在回复、回复是否可靠、进度是否可见。

## 目标用户与主要场景

- **个人用户**：和一个或多个 agent 协作解决问题（代码、写作、调研）
- **多 agent 协作**：需要分工（调研/实现/评审）、并行推进、快速汇总结果
- **长对话项目**：反复在一个群聊里推进同一目标，持续有记录与可回溯

## 关键体验原则（对标传统 IM）

1. **一致的聊天体验**
   - 私聊/群聊界面一致，交互一致
   - 发消息就是"发消息"，不暴露任务概念
2. **清晰的成员身份**
   - 每条消息明确是谁说的（用户/agent）
   - 群聊里 agent 有头像、昵称、角色标签
3. **熟悉的 @ 机制**
   - `@agent` 指定目标
   - 不 @ 时按默认策略（例如：默认主 agent 或广播）
4. **可预期的响应**
   - 消息发出后立刻看到"已送达/处理中"
   - agent 回复体现"输入中/处理中"的状态
5. **无需理解底层任务**
   - 只有在需要深入时，才暴露"任务详情"入口
   - 默认视角就是"群聊 + 多成员"

## 主要用户需求拆解

### 1) 发消息：像 IM 一样简单

- 用户打开聊天，直接输入消息
- 若群聊里有多个 agent：
  - @ 特定 agent → 仅该 agent 回复
  - 不 @ → 默认主 agent 回复（可配置）
  - 可切换"广播模式"，让多个 agent 并行回复

### 2) 看回复：谁在说、何时完成

- 群聊里每条消息都有清晰来源
- agent 可能同时回复，顺序按聊天时间流
- agent 的"处理中"状态以轻量方式显示（头像旁小点、状态条）

### 3) 协作结果聚合

- 多 agent 并发后，用户希望看到：
  - 每个 agent 的最终结论/输出
  - 一个"总结视图"（可由主 agent 汇总）
- 需要一种轻量"汇总卡片"（类似群聊公告）

### 4) 对话长期可持续

- 群聊历史像普通 IM 一样可翻
- Agent 的任务结果以消息形式保留
- 需要可以定位到某个 agent 的历史内容（过滤/搜索）

## 产品功能设计（分层）

### 1. 群聊成员管理

- 群聊创建时支持选择多个 agent
- 群聊成员列表展示 agent 角色（例如：研究/实现/评审）
- 允许在聊天中动态添加/移除 agent

### 2. 消息发送策略

默认模式（最简单）：
- 群聊有一个"默认 agent"
- 不 @ → 默认 agent 回复
- @agent → 指定 agent 回复

高级模式（可选）：
- "广播"开关：一次消息触发多个 agent
- "角色指派"模板：比如 "A 负责调研，B 负责实现，C 负责 review"

### 3. 状态与进度反馈

- agent 回复前显示"正在处理"
- 多 agent 并行时，聊天顶部展示简要状态条
- 完成后以"完成提示"形式插入聊天流

### 4. 结果聚合与总结

- 每个 agent 完成后自动生成"结果卡片"
- 可在聊天内触发"总结一下"，由主 agent 汇总多 agent 内容

### 5. 深入入口（不打扰主体验）

- 群聊默认不显示任务概念
- 需要时提供"查看任务详情"入口（比如点 agent 消息展开）
- 高级用户可查看每个 agent 的执行日志

## 里程碑建议（产品优先）

1. **MVP：IM 级体验**
   - 群聊 + 多 agent 成员
   - @ 指定 agent、默认 agent
   - 多 agent 并行回复
2. **增强：状态与总结**
   - 处理状态 UI
   - 结果卡片、总结
3. **高级：协作策略**
   - 广播/角色分工
   - 自定义 agent 角色

## 风险与待确认问题

- 默认策略：不 @ 时是"默认 agent"还是"广播"？
- 群聊里多个 agent 同时回复，是否会让用户感到混乱？
- 结果卡片是否需要统一格式来提升可读性？
- 成本与性能：多 agent 并发对预算影响

---

## 技术改造点

### 1. Chat 数据模型优化

**现状**：
- Chat 没有 title 字段
- 私聊显示逻辑：找第一个 agent 成员，显示其名字

**改造**：
- Chat 增加 `title: String?` 字段
- 显示逻辑（参考 Slack/Discord）：
  - 私聊 (direct)：title 为 null，前端动态查 Agent.name 显示
  - 群聊 (group)：title 可选，有则显示，无则拼接成员名（"Claude, Cursor and 2 others"）

**原因**：
- 私聊不存 name 是因为对方改名时显示应跟着变，避免同步问题
- 群聊 name 是共享的，需要持久化
- 这与 Slack/Discord 的设计一致

**涉及文件**：
- `shared/src/http/chat.ts` - Chat schema
- `api/prisma/schema.prisma` - 数据库模型
- `app/sources/components/MainView/index.tsx` - Chat list 显示逻辑

### 2. Chat 事件流：虚拟 Task + Planner 架构

**现状**：
- 消息存储在 TaskEvent，属于 Task
- 用户发消息必须先创建 Task
- 没有 Chat 级别的消息入口

**改造方案**：

```
Chat
  └── 虚拟 Task (id === chatId)
        ├── agentId = Planner（超强规划者，使用 Opus）
        ├── worker 按需唤醒
        └── 所有 Chat 消息存储在虚拟 Task 的 TaskEvent 里
```

**Planner 的职责**：
1. 理解用户意图
2. 简单问题直接回复
3. 复杂任务创建真实 Task
4. 解析 @ 机制：
   - 单 @ → 创建 Task 给该 agent
   - 多 @ → 拆解任务，创建多个 Task（并行或串行）
5. 创建 Task 时改写任务描述，传递必要上下文

**消息流**：
```
用户消息
    ↓
Resume 虚拟 Task (Planner)
    ↓
Planner 理解意图：
  - 无 @，简单问题 → 直接回复
  - 无 @，复杂任务 → 创建 Task（Planner 选 agent）
  - 单 @ → 创建 Task 给该 agent
  - 多 @ → 拆解任务，创建多个 Task
    ↓
真实 Task 独立执行（不继承 Chat 上下文，由 Planner 改写任务描述传递上下文）
```

**设计决策**：
- **复用现有逻辑**：虚拟 Task 复用 worker 的上下文管理、压缩、记忆
- **Planner 是调度器，不是执行者**：理解意图 + 创建 Task，不亲自执行复杂任务
- **真实 Task 独立上下文**：不继承 Chat 历史，由 Planner 在创建时传递 summary
- **效果优先**：Planner 使用 Opus 模型，暂不考虑成本优化

**数据模型改动**：
- Task 增加 `type: 'chat' | 'work'` 字段区分虚拟/真实 Task
- 或 `isVirtual: boolean`
- 虚拟 Task：agentId = Planner，machineId/cloudId/repositoryId 等为 null，state 永远 active

**待定细节**：
- 虚拟 Task 的 worker 生命周期（常驻 vs 按需唤醒 + 超时销毁）

### 3. Planner 的 UI 展示

**决策：Planner 有独立身份，显示为"群助手"**

**私聊 vs 群聊**：
- 私聊：不需要 Planner，虚拟 Task 直接绑定聊天对象（真实 agent）
- 群聊：虚拟 Task 绑定 Planner

**Planner 展示方案**：
| 属性 | 设计 |
|------|------|
| 名称 | "助手" / "协调者"（可自定义） |
| 头像 | 独特设计，区别于普通 agent |
| 身份 | 系统级，所有群聊共用同一个 Planner agent |
| 展示 | 群成员列表里显示，有特殊标识（角色标签"协调者"） |

**不采用伪装的原因**：
1. **行为决定身份**：Planner 说"我让 Claude 处理"，伪装成 Claude 会让用户困惑
2. **透明比伪装好**：伪装会带来信任问题，透明更健康
3. **简化设计**：不需要解决"伪装成谁"的逻辑

**"默认 Agent" 的定位**：
- 不是 Planner 伪装成谁
- 而是 Planner 的调度策略：不 @ 时优先分配任务给谁

### 4. Chat 事件流：两层信息架构

**设计原则**：Chat 事件流是"高层次会议纪要"，Task 详情是"完整工作日志"。

**Chat 事件流包含**：
| 类型 | 内容 |
|------|------|
| 用户消息 | 原文 |
| Planner 回复 | 意图理解 + 决策说明 |
| Agent 讨论发言 | agent 对问题的直接回复（非任务执行） |
| Task 创建 | 通知卡片（标题、分配给谁） |
| Task 状态 | 进行中 / 等待确认 / 已完成 / 失败 |
| Task 结果 | 简短总结 + 关键产出（PR、文件变更） |
| Planner 转述的澄清 | "Claude 需要确认：xxx？" |

**Task 详情（展开/详情页）包含**：
- Agent 的完整对话（思考、回复）
- 工具调用详情
- 代码 diff
- 执行日志

### 5. 讨论模式 vs 执行模式

**核心洞察**：不是所有交互都需要创建 Task，群聊还需要"讨论"的能力。

**两种模式**：

| 模式 | 触发条件 | 行为 | 例子 |
|------|----------|------|------|
| 讨论 | 咨询、讨论、轻量问答 | Agent 直接在 Chat 发言 | "@Claude 你觉得用 JWT 还是 Session？" |
| 执行 | 需要做具体工作 | 创建 Task，通过 Planner 汇报 | "@Claude 帮我实现 JWT 登录" |

**讨论模式**：
- Agent 直接在 Chat 事件流发言
- 不创建 Task，轻量快速
- 让群成员感觉"活的"，有群聊互动感

**执行模式**：
- 创建真实 Task
- 任务结果通过任务卡片展示
- 澄清问题通过 Planner 转述

**由 Planner 判断**使用哪种模式：
```
用户消息
    ↓
Planner 理解意图
    ├─ 讨论/咨询 → 让 @的 agent 直接在 Chat 回复
    └─ 执行任务 → 创建 Task
```

### 6. 澄清问题的处理链路

**终态设计**：用户只和 Planner 对话，Task 是"后台工作"。

**信息流**：
```
Claude (Task内): 需要确认：用邮箱还是用户名？
    ↓
通知 Planner (虚拟 Task)
    ↓
Planner 检查 Chat 历史
    ├─ 找到答案 → 直接回复 Claude，用户无感知
    └─ 没找到 → 在 Chat 里问用户（转述）
    ↓
用户回复 Planner
    ↓
Planner 转发给 Claude
```

**Chat 展示**：
```
[助手] Claude 在实现过程中需要确认：
       用户登录用邮箱还是用户名？

[用户] 用邮箱

[助手] 好的，已告知 Claude。
```

**好处**：
1. 交互一致性：用户只和 Planner 对话
2. 减少打扰：Planner 可根据上下文自动回答
3. 任务隔离：用户不需要关心 Task 细节
